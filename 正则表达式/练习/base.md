# 基本正则知识点

> 参考链接 [正则](https://blog.csdn.net/h610443955/article/details/81079439)

## 第一章 正则表达式字符匹配攻略
### 简洁写法

- \d：匹配任何数字字符（等同于[0-9]） 记忆方式：其英文是digit
- \D：匹配任何非数字字符（等同于[^0-9]）
- \w：匹配任何字母、数字或下划线字符（等同于[a-zA-Z0-9_]） 记忆方式：w是word的简写，也称单词字符
- \W：匹配任何非字母、数字或下划线字符（等同于[^a-zA-Z0-9_]）
- \s：匹配任何空白字符（包括空格、制表符、换页符等） 记忆方式：s是space character的首字母。
- \S：匹配任何非空白字符
- \b：单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。
- \B 非单词边界。
- .：匹配任何单个字符（除了换行符）记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。
- ^：匹配字符串的开始
- $：匹配字符串的结束
- *：匹配前面的元素零次或多次 （等同于{0,}）记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
- +：匹配前面的元素一次或多次 （等同于{1,}）记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
- ?：匹配前面的元素零次或一次 （等同于{0,1}） 记忆方式：问号的意思表示，有吗？
- {n}：匹配前面的元素恰好n次
- {n,}：匹配前面的元素至少n次
- {n,m}：匹配前面的元素至少n次，至多m次

### 字符组
需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。

### 量词
{n,m}为量词，后面加个？为惰性匹配，否则默认为贪婪匹配。
- 贪婪匹配：尽可能的多匹配。
- 惰性匹配：尽可能的少匹配。记忆方式：量词后面加个问号，问一问你知足了吗，你很贪婪吗？

示例：
- 贪婪匹配
```js
var regex = /\d{2,5}/g;
 
var string = "123 1234 12345 123456";
 
console.log( string.match(regex) );
 
// => ["123", "1234", "12345", "12345"]
```
- 惰性匹配
```js
var regex = /\d{2,5}?/g;
 
var string = "123 1234 12345 123456";
 
console.log( string.match(regex) );
 
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```
通过在量词后面加上问号就能实现惰性匹配，因此所有的惰性匹配情形如下：
```js
{m,n}?
{m,}?
??
+?
*?
```

### 分支多选
一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。

例如要匹配"good"和"nice"可以使用/good|nice/。

```js
var regex = /good|nice/g;
 
var string = "good idea, nice try.";
 
console.log( string.match(regex) );
 
// => ["good", "nice"]
```
但有个事实我们应该注意，比如我用/good|goodbye/，去匹配"goodbye"字符串时，结果是"good"：
```js
var regex = /good|goodbye/g;
 
var string = "goodbye";
 
console.log( string.match(regex) );
 
// => ["good"]
```
而把正则改成/goodbye|good/，结果是：
```js
var regex = /goodbye|good/g;
 
var string = "goodbye";
 
console.log( string.match(regex) );
 
// => ["goodbye"]
```
也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。


## 第二章 正则表达式位置匹配攻略
正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。
然而大部分人学习正则时，对于匹配位置的重视程度没有那么高。对于位置的理解可以理解为空字符串。


### (?=p)和(?!p)
(?=p)，其中p是一个子模式，即p前面的位置。
比如(?=l)，表示'l'字符前面的位置，例如：
```js
var result = "hello".replace(/(?=l)/g, '#');
console.log(result);
// => "he#l#lo"
```
而(?!p)就是(?=p)的反面意思，比如：
```js
var result = "hello".replace(/(?!l)/g, '#');
console.log(result);
// => "#h#ell#o#"
```
二者的学名分别是positive lookahead和negative lookahead。
中文翻译分别是正向先行断言和负向先行断言。
ES6中，还支持positive lookbehind和negative lookbehind。
具体是(?<=p)和(?<!p)。
也有书上把这四个东西，翻译成环视，即看看右边或看看左边。
但一般书上，没有很好强调这四者是个位置。
比如(?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符。
而在本人看来(?=p)就与^一样好理解，就是p前面的那个位置。

### 位置的特性
对于位置的理解，我们可以理解成空字符""。
比如"hello"字符串等价于如下的形式：
```js
"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + "";
```
也等价于
```js
"hello" == "" + "" + "hello"
```

